# 트랜잭션 설계 및 이벤트 처리 보고서

## 1. 개요

`Payment` 서비스는 결제 프로세스를 처리하며, 사용자 잔액 차감, 예매 정보 갱신, 좌석 상태 업데이트, 대기열 토큰 만료와 같은 다양한 도메인 로직을 관리  
이를 위해 트랜잭션과 이벤트 리스너를 활용해 데이터 정합성을 유지하면서도 도메인 간 의존성을 최소화할 수 있습니다.  
또한, **보상 트랜잭션** 및 **사가 패턴**의 오케스트레이터와 코레오그래피 전략도 고려하여, 분산된 트랜잭션 처리의 확장성을 염두에 둔 설계를 진행하고자 합니다.

---

## 2. 주요 기능

### 2.1 결제 처리 (`payment` 메서드)

- **기능:** 결제 데이터를 생성하고, 사용자의 잔액을 차감하며, 결제 성공 이벤트를 발행
- **주요 작업:**
    1. `Payment` 엔티티를 생성 및 저장
    2. `Reservation` 정보를 검증 및 조회
    3. 잔액 차감을 위해 `BalanceService`를 호출
    4. `PaymentSuccessEvent`를 발행
- **트랜잭션 처리:**
    - `@Transactional`을 사용하여 메서드 전체를 하나의 트랜잭션으로 처리할 수 있습니다.
    - 트랜잭션이 완료되지 않으면 이벤트가 발행되지 않아 데이터 정합성을 보장할 수 있습니다.

잔액 차감은 메인 비지니스 로직이기에 차감 후에 이벤트 발행

---

### 2.2 결제 성공 이벤트 처리 (`handlePaymentSuccess`)

- **기능:** 결제 성공 시 예약 상태와 좌석 상태를 변경
- **주요 작업:**
    1. `ReservationStatusUpdateEvent`를 발행
    2. `SeatStatusUpdateEvent`를 발행
- **트랜잭션 처리:**
    - `@TransactionalEventListener`를 사용하여 **커밋 전**에 이벤트를 처리할 수 있습니다.
    - `TransactionPhase.BEFORE_COMMIT`을 설정하여 트랜잭션이 성공적으로 완료될 준비 상태에서 도메인 이벤트를 발행할 수 있습니다.

---

### 2.3 대기열 토큰 만료 (`expireQueueToken`)

- **기능:** 결제가 완료된 이후 사용자의 대기열 토큰을 만료 처리
- **주요 작업:**
    1. `QueueTokenRepository`를 호출하여 활성화된 토큰을 만료 처리
- **트랜잭션 처리:**
    - `@TransactionalEventListener`를 사용하여 **커밋 후**에 작업을 처리할 수 있습니다.
    - `TransactionPhase.AFTER_COMMIT`을 설정하여 트랜잭션이 성공적으로 커밋된 이후 토큰 만료 작업을 수행합니다.

실패해도 결제 서비스에 영향을 주지 않도록 커밋 후에 구현

---

## 3. 트랜잭션 성능 비교

트랜잭션 분리 여부에 따른 성능 비교(**k6활용**):

| **항목**               | **트랜잭션 분리 이후** | **트랜잭션 분리 이전** |
|----------------------|----------------|----------------|
| **응답 시간 (Duration)** | 평균 54.42ms     | 평균 244.04ms    |
| **대기 시간 (Waiting)**  | 평균 53.4ms      | 평균 241.96ms    |

약 5배의 속도 증가

---

## 4. 보상 트랜잭션 및 사가 패턴

### 4.1 보상 트랜잭션

- **정의:** 트랜잭션이 실패했을 때, 이전 상태로 복구하기 위한 보상 작업을 실행
- **적용 방안:**
    - 결제 실패 시 잔액을 복구하는 작업을 수행 가능
    - 예약 상태 및 좌석 상태를 원래 상태로 복구 가능
- **장점:**
    - 데이터 일관성을 유지
    - 트랜잭션 실패 시에도 시스템 상태를 신뢰 가능
- **단점:**
    - 복구 로직 추가로 인해 복잡도가 증가
    - 시스템 설계 및 테스트가 어려워질 수 있습니다.

---

### 4.2 사가 패턴

#### 4.2.1 오케스트레이터(Orchestrator) 전략

- **정의:** 중앙 집중식 오케스트레이터가 트랜잭션의 상태와 진행을 관리
- **적용 방안:**
    - `PaymentOrchestrator`를 추가하여 결제 프로세스를 조정 가능
    - 각 단계 실패 시 보상 트랜잭션을 호출 가능
- **장점:**
    - 트랜잭션 상태를 명확히 관리 가능
    - 복잡한 비즈니스 로직을 중앙에서 관리 가능
- **단점:**
    - 오케스트레이터 자체가 단일 장애 지점(SPOF)이 될 가능성이 있습니다.
    - 서비스 간 의존성이 높아질 수 있습니다.

#### 4.2.2 코레오그래피(Choreography) 전략

- **정의:** 각 서비스가 이벤트를 기반으로 독립적으로 트랜잭션을 처리
- **적용 방안:**
    - `PaymentSuccessEvent`, `ReservationStatusUpdateEvent`, `SeatStatusUpdateEvent` 등 이벤트를 기반으로 도메인 간 트랜잭션을 처리할 수 있습니다.
- **장점:**
    - 도메인 간 결합도를 낮출 수 있습니다.
    - 확장성과 유지보수성을 향상 가능
- **단점:**
    - 이벤트 흐름이 복잡해질 가능성이 있습니다.
    - 이벤트 순서와 장애 처리 로직을 설계하기 어려울 수 있습니다.

---

#### 4.3 전략 고려

1. 트랜잭션 안정성을 위해 **보상 트랜잭션**을 추가하여 실패 시 데이터 복구를 보장 가능
2. 초기에는 **오케스트레이터 전략**을 도입하되, 필요 시 **코레오그래피 전략**으로 전환할 수 있도록 설계 가능

---

## 5. 결론

`Payment` 서비스의 트랜잭션 설계는 데이터 정합성을 유지하면서도 비즈니스 로직의 독립성을 확보하는 데 초점을 맞추고 있습니다.  
**보상 트랜잭션**과 **사가 패턴**을 활용하여 확장성과 복원력을 갖춘 분산 트랜잭션 시스템을 설계할 수 있습니다.  
